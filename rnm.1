.\" Automatically generated by Pandoc 1.16.0.2
.\"
.TH "rnm" "1" "January 26, 2017" "rnm user manual" ""
.hy
.SH NAME
.PP
rnm \- Bulk rename utility
.SH SYNOPSIS
.PP
\f[B]rnm\f[] [\f[I]options\f[]] \f[I]file/paths\f[]
.SH DESCRIPTION
.PP
Renames files/directories in bulk.
Naming scheme (\f[I]Name String\f[]) can be applied or rgex replace can
be performed to modify names dynamically.
It uses PCRE2 (revised version of PCRE) regex to provide search (and
replace) functionality.
It provides an undo functionality too to move back unwanted rename
operations.
You can also run a simulation instead of actual rename to view the
potential outcome as program output on terminal with the \f[I]\-sim\f[]
option.
.SH USAGE
.IP
.nf
\f[C]
rnm\ \-ns\ new_name\ [other\-opts]\ file/path
rnm\ \-rs\ "/search/replace/mod"\ [other\-opts]\ file/path
rnm\ \-ns/f\ namestring/file/path\ file/path
\f[]
.fi
.PP
Options are \f[B]not\f[] sequential, their position in the argument list
holds no significance.
For example, \f[B]rnm filepath \-ns name\f[] is the same as \f[B]rnm
\-ns name filepath\f[].
Though passing the file path at the end of the argument list is
considered to be safe.
.PP
Options are case insensitive, i.e \f[I]\-ssF\f[] and \f[I]\-ssf\f[] are
the same.
.SH OPTIONS
.TP
.B \-h, \-\-help
Show help menu.
.RS
.RE
.TP
.B \-ns \f[I]string\f[]
Name string.
This is generally the new name for the file.
Any part in this name string wrapped around with the path delimiter (/)
is parsed as a name string rule and the new name is formed accordingly.
See NAME STTRING RULE for details.
.RS
.RE
.TP
.B \-ns/f \f[I]file\-path\f[]
Name string file.
File containing name string (one per line).
.RS
.RE
.TP
.B \-ns/fn \f[I]file\-path\f[]
Name String file.
This takes a null terminated \f[I]Name String\f[] file, i.e a file where
filenames are terminated by null character (\f[I]\\0\f[]) instead of new
line (\f[I]\\n\f[]).
.RS
.RE
.TP
.B \-ss \f[I]search\-regex\f[]
Search string.
String that will be used to search for files with matching names.
This is generally a regex if not passed with \f[I]\-ssf\f[] option.
See SEARCH STRING for details.
.RS
.RE
.TP
.B \-ss/f \f[I]file\-path\f[]
Search string file.
A file containing search string per line.
.RS
.RE
.TP
.B \-ssf \f[I]search\-term\f[]
Fixed search string (not treated as regex).
See SEARCH STRING for details.
.RS
.RE
.TP
.B \-ssf/f \f[I]file\-path\f[]
Search string file.
Contains fixed search string per line.
.RS
.RE
.TP
.B \-rs \f[I]replace\-string\f[]
A string in the form \f[I]/search_regex/replace_part/modifier\f[].
See REPLACE STRING for details.
.RS
.RE
.TP
.B \-rs/f \f[I]file\-path\f[]
Replace string file.
A file containing replace string per line.
.RS
.RE
.TP
.B \-i \f[I]number\f[], \-si \f[I]number\f[]
Starting index.
.RS
.RE
.TP
.B \-ei \f[I]number\f[]
End index i.e index to stop renaming from.
It is only for files inside a directory that is being recursively taken
due to a depth value greater than 0, i.e it works on directory index.
Note that directory index \f[I]/id/\f[] will renew in each directory i.e
in each directory rename will be performed from start index to end
index.
.RS
.RE
.TP
.B \-inc \f[I]positive\-integer\f[]
Increment value (floating point decimal).
The amount, index will be incremented or decremented in each iteration.
Decremented index is available through name string rule \f[I]/\-i/\f[],
\f[I]/\-id/\f[] etc..
.RS
.RE
.TP
.B \-linc \f[I]positive\-integer\f[]
The amount line count will be incremented or decremented in each
iteration.
This is always a positive integer.
.RS
.RE
.TP
.B \-if \f[I]INDEX\-FLAGS\f[]
This sets Index flags.
This is a \[aq]/\[aq] separated list of flags that will be used to
render the index within it\[aq]s text field.
The general format is \f[I]\[aq]/keyword1/keyword2/...\[aq]\f[].
Valued flags are set with \f[I]keyword=value\f[] format.
Ex: \f[I]\[aq]/uppercase/filler=*/\[aq]\f[].
See INDEX FLAGS for details.
.RS
.RE
.TP
.B \-ifl \f[I]positive\-integer\f[]
Index field length.
Non occupied field will be filled with index field fillers (set with
\f[I]\-iff\f[]).
\f[I]iff\f[] is set to the character \f[I]0\f[] by default.
.RS
.RE
.TP
.B \-iff \f[I]character\f[]
Not occupied field in index will be filled with a character which is set
by this option.
.RS
.RE
.TP
.B \-ifp \f[I]positive\-integer\f[]
Index is a floating point decimal value.
This sets the precision.
.RS
.RE
.TP
.B \-l \f[I]positive\-integer\f[], \-sl \f[I]positive\-integer\f[]
Start Line number in name string file.
If it\[aq]s smaller the end line number, the line number is incremented
in each iteration and if it\[aq]s greater than end line number, line
number will be decremented in each iteration till it reaches end line
number
.RS
.RE
.TP
.B \-lv \f[I]positive\-integer\f[], \-slv \f[I]positive\-integer\f[]
Same as \f[I]\-l\f[] or \f[I]\-sl\f[], except it reverses their meaning.
.RS
.RE
.TP
.B \-el \f[I]positive\-integer\f[]
End line number.
Line number to stop renaming from.
\-elv \f[I]positive\-integer\f[]
.RS
.RE
Same as \f[I]\-el\f[], except it reverses their meaning.
.RS
.RE
.TP
.B \-dp \f[I]integer\f[]
Depth of folder.
\-1(any negative number) means unlimited depth i.e all files and
subdirectories will be included.
Other values may be 0 1 2 3 etc...
Default depth is \f[I]0\f[], i.e directory contents will be ignored.
.RS
.RE
.TP
.B \-fo
File only mode.
Only files are renamed (not directory).
Goes to subdirectory/s if depth (\f[I]\-dp\f[]) is set to \f[I]1\f[] or
greater.
.RS
.RE
.TP
.B \-do
Apply rename on directory only.
.RS
.RE
.TP
.B \-ed
Apply rename on files only, exclude any and all directory and their
contents.
This option is equivalent to file only mode with a zero (\f[I]0\f[])
depth value.
.RS
.RE
.TP
.B \-cd
Count directory in reserved index, regardless of other options.
Reserves indexes for directories even if it is File Only mode.
.RS
.RE
.TP
.B \-cf
Count file in reserved index, regardless of other options.
Reserves indexes for files even if it is Directory Only mode.
.RS
.RE
.TP
.B \-s
Sort files in natural order (Human perceivable order).
This option can be modified to use other sorting methods.
For example: \f[I]\-s/g\f[] or \f[I]\-\-sort/g\f[] will sort the file in
general (alphabetical) order.
Other options are \f[I]\-s/n\f[] (Natural sort), \f[I]\-s/none\f[] (No
sort).
.RS
.RE
.TP
.B \-y
Confirm Yes to all.
.RS
.RE
.TP
.B \-fl
Follow symbolic link.
.RS
.RE
.TP
.B \-u
Undo renaming
.RS
.RE
.TP
.B \-f, \-\-force
Force rename.
Enables renaming some restricted files except \f[I]/\f[].
.RS
.RE
.TP
.B \-v
Show version info.
.RS
.RE
.TP
.B \-q
Quiet operation (this increases the speed).
.RS
.RE
.TP
.B \-\-
If this option is passed, anything and everything after it will be taken
as file path.
Put all options before passing this option.
.RS
.RE
.TP
.B \-sim
This runs a simulation of rename instead of actual rename operation.
.RS
.RE
.SH TERMINOLOGY
.PP
These are the technical terms that will be thrown around a bit for
convenience.
.SS RESERVED INDEX
.PP
Index will be incremented even if any file is skipped renaming in order
to reserve the index for that skipped file.
These are constructed by appending the \f[C]r\f[] character with the
index identifier, e.g \f[I]/ir/\f[], \f[I]/\-idr/\f[] etc..
.SS REVERSE INDEX
.PP
Decrementing index.
These are constructed by inserting a \f[I]\-\f[] before the index
identifier e.g \f[I]/\-i/\f[], \f[I]/\-id/\f[] etc..
.SS NAME STRING
.PP
A string, that is parsed to create names for new files.
It can be fixed name which then can be modified for different files at
runtime.
Name sting is parsed by some rules (Name String Rule).
(must be wrapped around with filepath delimiter \f[I]/\f[]).
.SS NAME STRING RULE
.PP
A name string rule starts and ends with a \f[I]/\f[] character, These
special forms are parsed and expanded to their meaning.
For example \f[I]/i/\f[] would expand to file index.
.SS INDEX RULES
.IP "1." 3
\f[I]/i/\f[] : Index.
.IP "2." 3
\f[I]/ir/\f[] : Reserved index.
.IP "3." 3
\f[I]/id/\f[] : Directory index (index inside a directory).
.IP "4." 3
\f[I]/idr/\f[] : Reserved directory index
.IP "5." 3
\f[I]/\-i/\f[] : Inverse index.
.IP "6." 3
\f[I]/\-ir/\f[] : Inverse reserved index.
.PP
In general, \f[I]\-i\f[] in the above name string rules will mean
inverse index conforming to their meaning.
.SS EXTENDED INDEX RULES
.IP "1." 3
\f[B]Base conversion: Format\f[]: \f[I]/<rule>\-b<base>/\f[], e.g
\f[I]/i\-b8/\f[] will convert the index to octal.
<base> can be 2 to 36.
.IP "2." 3
\f[B]Scientific conversion\f[]: Format: \f[I]/<rule>\-s/\f[], e.g
\f[I]/i\-s/\f[] will convert the index to scientific form (n.fE+\-p)
.IP "3." 3
\f[B]Latin conversion\f[]: Format: \f[I]/<rule>\-l/\f[], e.g
\f[I]/i\-l/\f[] will convert the index to latin form.
.PP
\f[B]Examples:\f[]
.IP
.nf
\f[C]
#indexing:
rnm\ \-ns\ \[aq]/fn/\ /i/\[aq]\ ./*
#indexing\ by\ directory:
rnm\ \-ns\ \[aq]/fn/\ /id/\[aq]\ ./*
#indexing\ with\ binary\ number
rnm\ \-ns\ \[aq]/fn/\ /id\-b2/\[aq]\ ./*
#indexing\ with\ scientific\ number
rnm\ \-ns\ \[aq]/fn/\ /id\-s/\[aq]\ ./*
#indexing\ with\ latin\ number
rnm\ \-ns\ \[aq]/fn/\ /id\-l/\[aq]\ ./*
\f[]
.fi
.SS COUNTERS
.IP "1." 3
\f[I]/dc/\f[] : directory count
.IP "2." 3
\f[I]/l/\f[] : line number from \f[I]Name String File\f[].
.IP "3." 3
\f[I]/la/\f[] : actual line number from \f[I]Name String File\f[].
.SS FILENAME
.IP "1." 3
\f[I]/fn/\f[] : Full name of the files.
If used with \f[I]\-ns/f\f[] option, full name will be taken from the
\f[I]Name String File\f[].
.IP "2." 3
\f[I]/n/\f[] : Name without extension.
If used with \f[I]\-ns/f\f[] option, name will be taken from the
\f[I]Name String File\f[].
.IP "3." 3
\f[I]/e/\f[] : File extension.
.IP "4." 3
\f[I]/rn/\f[] : Replaced Name, generated by replace strings.
.IP "5." 3
\f[I]/pd/\f[] : Parent directory name of the current file or directory.
.IP "6." 3
\f[I]/wd/\f[] : Current working directory name.
.SS EXTENDED PD RULES
.PP
Its general format is \f[I]/pd<digits>\-<digits>\-delimiter/\f[].
It specifies a bidirectional range of parent directories.
.IP "1." 3
\f[I]/pd0/\f[] is the immediate parent directory name, \f[I]pd1\f[] is
the directory before \f[I]pd0\f[] and so forth.
.IP "2." 3
\f[I]/pd0\-2\-+/\f[] will expand by concatenating pd0 to pd2 and with
the \f[I]delimiter\f[] in\-between (e.g \f[I]dir0+dir1+dir2\f[]).
.IP "3." 3
\f[I]/pd2\-0\-+/\f[] will do the same as above but in reverse order
(\f[I]dir2+dir1+dir0\f[]).
.IP "4." 3
In place of \f[I]<digits>\f[] you can supply \f[I]e\f[] which generally
means the \[aq]end\[aq] i.e the deepest level available.
.IP "5." 3
In place of \f[I]<digits>\f[] you can also supply \f[I]w\f[] which means
the level of working directory.
.IP "6." 3
Any unavailable level of directory will be ignored and be replaced with
empty string.
.PP
\f[B]Examples:\f[]
.IP
.nf
\f[C]
#Appending\ parent\ directory\ names
#with\ space\ in\-between
rnm\ \-ns\ \[aq]/pd0\-e\-\ /\[aq]\ ./*
rnm\ \-ns\ \[aq]/pdw\-0\-\ /\[aq]\ ./*
\f[]
.fi
.SS INFO\-NAME STRING RULE
.PP
This name string rule provides basic information about a file, directory
or link.
The general format of this rule is: \f[I]/info\-prop\-op/\f[], where
\f[I]info\-\f[] is the identifier for this rule, \f[I]prop\f[] is the
property name and \f[I]op\f[] is an optional entry which is used for
additional formatting.
.PP
\f[B]File time:\f[]
.TP
.B \f[I]mtime\f[]
File modification time.
\f[B]op\f[]: Time format (default \f[I]%d\-%m\-%Y\f[])
.RS
.RE
.TP
.B \f[I]mtime,GMT\f[]
File modification time in GMT.
\f[B]op\f[]: Time format (default \f[I]%d\-%m\-%Y\f[])
.RS
.RE
.TP
.B \f[I]atime\f[]
File access time.
\f[B]op\f[]: Time format (default \f[I]%d\-%m\-%Y\f[])
.RS
.RE
.TP
.B \f[I]atime,GMT\f[]
File access time in GMT.
\f[B]op\f[]: Time format (default \f[I]%d\-%m\-%Y\f[])
.RS
.RE
.TP
.B \f[I]ctime\f[]
File status change time.
\f[B]op\f[]: Time format (default \f[I]%d\-%m\-%Y\f[])
.RS
.RE
.TP
.B \f[I]ctime,GMT\f[]
File status change time in GMT.
\f[B]op\f[]: Time format (default \f[I]%d\-%m\-%Y\f[])
.RS
.RE
.PP
\f[B]Time Formats:\f[]
.PP
Time format string is used to specify an arbitrary date\-time format.
For example, \f[I]%d\-%m%\-Y\f[] would produce something like
\f[I]22\-01\-2017\f[].
This format string is exactly the same as the format string taken by
\f[C]strftime\f[] (3).
Some frequently used character sequences:
.IP \[bu] 2
%a, %A: week day name short and full respectively
.IP \[bu] 2
%b, %B: month name short and full
.IP \[bu] 2
%d: month day number
.IP \[bu] 2
%H: Hour in 24hr format
.IP \[bu] 2
%I: Hour in 12hr format
.IP \[bu] 2
%j: Day of the year (001\-366)
.IP \[bu] 2
%m: month number
.IP \[bu] 2
%M: Minute
.IP \[bu] 2
%p: AM/PM
.IP \[bu] 2
%P: am/pm (lowercase)
.IP \[bu] 2
%S: second in a minute
.IP \[bu] 2
%t: tab character
.IP \[bu] 2
%u: week day number (1\-7)
.IP \[bu] 2
%%: A literal % character.
.PP
You can find a lot more of these character sequences described in
details
here (http://man7.org/linux/man-pages/man3/strftime.3.html#DESCRIPTION).
.PP
\f[B]Example:\f[]
.IP
.nf
\f[C]
rnm\ \-ns\ \[aq]/fn/\ \-\ /info\-mtime\-%d\-%m\-%Y\ %I:%M:%S\ %p/\[aq]\ ./*
#The\ above\ appends\ modification\ time\ to\ the\ file\ names.
\f[]
.fi
.PP
\f[B]File size:\f[]
.TP
.B \f[I]size\f[]
Size of file.
\f[B]op\f[]: Unit (default: chosen according to size)
.RS
.RE
.TP
.B \f[I]blksize\f[]
Size of system I/O block.
\f[B]op\f[]: Unit (default: chosen according to size)
.RS
.RE
.TP
.B \f[I]blocks\f[]
Number of 512B blocks.
\f[B]op\f[]: N/A
.RS
.RE
.PP
\f[B]Other info:\f[]
.TP
.B \f[I]perm\f[]
File permission.
\f[B]op\f[]: Either \f[I]ls\f[] or \f[I]oct\f[].
.RS
.RE
.TP
.B \f[I]uid\f[]
Owner ID.
\f[B]op\f[]: N/A
.RS
.RE
.TP
.B \f[I]gid\f[]
Group ID.
\f[B]op\f[]: N/A
.RS
.RE
.TP
.B \f[I]dev\f[]
Device ID.
\f[B]op\f[]: N/A
.RS
.RE
.TP
.B \f[I]inode\f[]
Inode number.
\f[B]op\f[]: N/A
.RS
.RE
.TP
.B \f[I]mode\f[]
File mode.
\f[B]op\f[]: N/A
.RS
.RE
.TP
.B \f[I]nlink\f[]
Number of hard links.
\f[B]op\f[]: N/A
.RS
.RE
.PP
\f[B]Examples:\f[]
.IP
.nf
\f[C]
#Appending\ different\ file\ info\ to\ their\ names
rnm\ \-ns\ \[aq]/fn/\ size:\ /info\-size/\[aq]\ ./*
rnm\ \-ns\ \[aq]/fn/\ size:\ /info\-size\-1024/\[aq]\ ./*\ #size\ in\ KB
rnm\ \-ns\ \[aq]/fn/\ octperm:\ /info\-perm\-oct/\ lsperm:\ /info\-perm\-ls/\[aq]\ ./*
rnm\ \-ns\ \[aq]/fn/\ uid:\ /info\-uid/\[aq]\ ./*
\f[]
.fi
.SS NAME STRING FILE
.PP
A file which contains a list of name string (one per line).
Empty lines will be ignored and line number won\[aq]t be counted.
Actual line number (which counts the empty lines too) is available
through the name string rule : \f[I]/la/\f[].
.SS SEARCH STRING
.PP
A string that is used to search for files with matching filenames
against the search string.
By default it is a regex if \f[I]\-ssf\f[] option is not used.
It is generally in the form \f[I]/regex/modifier\f[] , where
\f[I]regex\f[] is the regex to search for and available modifiers are
\f[I]i\f[] (case insensitive), \f[I]f\f[] (file), \f[I]d\f[]
(directory), \f[I]l\f[] (link), \f[I]!\f[] (inverse search).
If no modifier is used, the regex format can be reduced to
\f[I]/regex/\f[] or simply \f[I]regex\f[].
.PP
Terminate search strings (\f[I]/regex/\f[] format only) with \f[I];\f[]
to provide multiple search strings, e.g
\f[I]\[aq]/s1/i;/s2/;/s3/\[aq]\f[].
This applies to fixed search strings as well.
.PP
Also you can provide multiple search strings with repeated \f[I]\-ss\f[]
and/or \f[I]\-ssf\f[] options and files with repeated \f[I]\-ss/f\f[]
and/or \f[I]\-ssf/f\f[] options.
These options can be mixed with each other too.
.PP
\f[B]Examples:\f[]
.IP
.nf
\f[C]
#rename\ only\ mp3\ and\ mp4\ files
rnm\ \-ns\ \[aq]/fn/\ /i/\[aq]\ \-ss\ \[aq]/.*\\.mp(3|4)$/\[aq]\ ./*
#rename\ everything\ excluding\ mp3\ and\ mp4\ files
rnm\ \-ns\ \[aq]/fn/\ /i/\[aq]\ \-ss\ \[aq]/.*\\.mp(3|4)$/!\[aq]\ ./*
#rename\ file\ with\ .video\ in\ their\ names
#\ (fixed\ string\ search)
rnm\ \-ns\ \[aq]/fn/\ /i/\[aq]\ \-ssf\ \[aq].video\[aq]\ ./*
\f[]
.fi
.SS INDEX FIELD LENGTH
.PP
An integer value defining the field length of index.
By default empty field will be filled with 0\[aq]s.
For example, if the value is \f[I]3\f[], then index will be
\f[I]001\f[], \f[I]002\f[], \f[I]003\f[], etc..
Different filler (other than 0) can be provided with the \f[I]\-iff\f[]
option.
.SS REPLACED NAME
.PP
The name can be modified at runtime using replace string.
Replace string will be parsed to create a new \f[I]Name String\f[] rule:
\f[I]/rn/\f[] which can be used in \f[I]Name String\f[].
If name string is not passed as argument, the new name of the file will
be \f[I]/rn/\f[].
\f[I]Replaced Name\f[] is always generated from the old filename (even
when name string file is given).
.SS REPLACE STRING
.PP
\f[I]Replace String\f[] is of the form:
\f[I]/search_part/replace_part/modifier\f[] where search_part is the
regex to search for and replace_part is the string to replace with.
\f[I]Name String\f[] rules are available in search_part and replace_part
in Replace String.
.PP
There are several special cases for replace_part:
.IP "1." 3
\f[I]&\f[] will be taken as the entire match found by the regex
(search_part).
.IP "2." 3
\f[I]\\1\f[], \f[I]\\2\f[] etc..
is the captured groups.
If you want to isolate a captured group, wrap it around with
\f[I]{}\f[].
For example, if you want to put a digit (2) after captured group
\f[I]\\1\f[], you can\[aq]t use it like \f[I]\\12\f[].
\f[I]\\12\f[] will mean \f[I]12th\f[] captured group not \f[I] appended
with a digit (1). In this case isolate the captured group with \f[]{}*
i.e \f[I]\\{1}2\f[].
.IP "3." 3
\f[I]\\c\f[] will convert the matched string to lowercase, and
\f[I]\\C\f[] will convert it to uppercase.
No other character is allowed in replace part if this is used.
You can still concatenate different replace strings with \f[I];\f[].
.IP "4." 3
to insert a \f[I]&\f[] literally, use \f[I]\\&\f[] and for \f[I]\\\f[]
use \f[I]\\\\\f[].
.IP "5." 3
Modifiers are \f[I]i\f[] (case insensitive), \f[I]g\f[] (global),
\f[I]f\f[] (file), \f[I]d\f[] (directory), \f[I]l\f[] (link).
.IP "6." 3
\f[I]Replace String\f[] is always performed on old file name (even when
name string file is given).
.IP "7." 3
You can provide multiple replace strings with repeated \f[I]\-rs\f[]
option and multiple file with repeated \f[I]\-rs/f\f[] options.
These options can be mixed with each other too.
.PP
\f[B]Examples:\f[]
.IP
.nf
\f[C]
#convert\ to\ uppercase
rnm\ \-rs\ \[aq]/.*/\\C/\[aq]\ ./*
#convert\ to\ lowercase
rnm\ \-rs\ \[aq]/.*/\\c/\[aq]\ ./*
#replace\ all\ \@\ with\ \-\ in\ the\ names
rnm\ \-rs\ \[aq]/\@/\-/g\[aq]
#Treat\ files\ and\ directories\ differently
rnm\ \-rs\ \[aq]/\@/\-/gf;/#/\@/gd;\[aq]
#the\ above\ will\ replace\ all\ \@\ in\ file\ (not\ directory)
#names\ to\ \-\ and\ all\ #\ in\ directory\ names\ to\ \@
\f[]
.fi
.SS INDEX FLAGS
.IP \[bu] 2
\f[I]uppercase\f[] : means uppercase.
.IP \[bu] 2
\f[I]showpoint\f[] : show point regardless if it\[aq]s an integer or
floating point value.
.IP \[bu] 2
\f[I]showbase\f[] : means show base (Hex or Oct).
.IP \[bu] 2
\f[I]showpos\f[] : show + sign for positive numbers.
.IP \[bu] 2
\f[I]right\f[] : adjust right.
.IP \[bu] 2
\f[I]left\f[] : adjust left.
.IP \[bu] 2
\f[I]internal\f[] : adjust internal.
.IP \[bu] 2
\f[I]precision\f[] : set precision.
Used like precision=value
.IP \[bu] 2
\f[I]length\f[] : sets length.
Used like length=value
.IP \[bu] 2
\f[I]filler\f[] : sets filler.
Used like filler=value
.SS MODIFIERS
.IP "1." 3
\f[I]i\f[]: case insensitive match or replace.
.IP "2." 3
\f[I]g\f[]: global replace
.IP "3." 3
\f[I]f\f[]: True if it\[aq]s a file, otherwise false.
.IP "4." 3
\f[I]d\f[]: True if it\[aq]s a directory, otherwise false.
.IP "5." 3
\f[I]l\f[]: True if it\[aq]s a link, otherwise false.
.IP "6." 3
\f[I]!\f[]: inverse search.
.PP
The \f[I]f\f[], \f[I]d\f[] and \f[I]l\f[] modifiers are ORed when
combined.
.SS EXAMPLE:
.IP
.nf
\f[C]
rnm\ file\ \-ns\ new_file
rnm\ file\ \-rs\ "/f/F/"
#\-do\ forces\ Directory\ only\ mode
rnm\ folder\ \-ns\ "New\ Folder"\ \-do
rnm\ ./New*/*\ \-ns\ /i/.ext
#This\ will\ go\ inside\ the\ New\ Folder\ directory
rnm\ "./New\ Folder"\ \-ns\ /id//dc/.ext\ \-dp\ 1\ \-fo
#\ \-dp\ \-1\ (infinite\ depth)
rnm\ "./New\ Folder"\ \-ns\ /id//dc/.ext\ \-dp\ \-1\ \-fo
rnm\ ./New*\ \-ns\ /id/.ext\ \-ss\ "regex"
rnm\ \-ns/f\ filepath\ \-ns\ /n//id/.ext
rnm\ \-ns/f\ filepath
\f[]
.fi
.PP
\f[B]Only invalid characters for a file or directory name is the path
delimiter (/) and the null character (\f[I]\\0\f[]).\f[]
.SH THINGS TO CARE
.IP "1." 3
All options should always be separated by space.
For Example: \f[I]\-vy\f[] won\[aq]t mean two option \f[I]\-v\f[] and
\f[I]\-y\f[], rather it will mean a single option \f[I]\-vy\f[].
.IP "2." 3
Any argument with \f[I]\-\f[] at beginning will be treated as an option
and produce error if invalid.
.IP "3." 3
If filename/path argument may include \f[I]\-\f[] at the beginning, use
\f[I]\-\-\f[] to make all the arguments after this option as paths/names
(not options).
.IP "4." 3
If you run \f[C]rnm\ .\ \-ns\ something\f[] or
\f[C]rnm\ ./\ \-ns\ something\f[], your current directory will be
renamed (be careful).
.IP "5." 3
This is a dangerous tool like \f[C]rm\f[], so use with care.
If you make a mistake and do some unwanted rename, run \f[C]rnm\ \-u\f[]
to undo (before running any more \f[B]rnm\f[] command).
.IP "6." 3
Pass all regex like strings within quotes even if they don\[aq]t contain
any white space.
.IP "7." 3
To pass a filename that resembles an option, use \f[C]\&./\f[], i.e
\f[C]\&./\-ns\f[] to pass a file named \f[C]\-ns\f[] in the current
directory.
Or you can use the \f[C]\-\-\f[] option to make it a non\-option
argument; in that case make sure to pass all "Option" arguments before
\f[C]\-\-\f[], because everything after \f[C]\-\-\f[] will be taken as
file path/s.
.IP "8." 3
A common mistake is to pass files like this:
\f[C]rnm\ \-ns\ \[aq]something\[aq]\ *\f[], it will work as long as no
file names contain \f[I]\-\f[] at the beginning, a safer approach is
\f[C]rnm\ \-ns\ \[aq]something\[aq]\ ./*\f[]
.SH AUTHORS
Md Jahidul Hamid <https://github.com/neurobin>.
